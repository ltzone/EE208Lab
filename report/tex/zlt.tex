
\chapter{商品检索与排序}

前文所述过程中建立的Lucene索引表和图像LSH哈希表是本章节商品检索与排序的根据，在本项目中，我们实现了两种检索方式——按关键词检索与按图片检索。

按关键词检索部分，用户可以输入商品关键词执行检索，也可以输入商品的品牌等属性执行高级检索。对检索的结果，用户可以选择按照相关度、价格顺序、评分高低进行排序。在图片检索中，用户上传图片后，可以选择LOGO匹配或精确匹配两种方式。LOGO匹配将图片与我们建立的产品品牌图库中的LOGO对比，计算SIFT特征向量的相似度，返回最有可能的品牌关键词执行关键词检索。精确匹配则将图片特征向量映射到前文建立的LSH哈希表中，返回匹配图片的URL列表，再到Lucene索引表中调用TermQuery匹配出URL对应的条目，按匹配度返回商品信息到前端中。关键词检索与相关度排序沿用了本课程此前实验的代码，不作详述。本章节将主要介绍高级检索、商品排序和图片匹配三个功能的实现。

\section{商品高级检索}


\subsection{接口设计}

在此前建立索引的过程中，对于所有商品都具备的属性，如品牌、来源网站等，我们建立了专门的可被索引的Field进行存储，在本节我们将实现对这些Field的多字段检索。

在编写检索程序的代码前，考虑到我们的项目需要整合多种检索和排序方式，包括关键词、多字段检索、价格排序、评分排序等，我们有必要做好统一的接口，实现多重功能在后端查询时的一致。

一方面，用户可能在高级查询页面给出多字段的查询请求，对此我们采取了此前实验中类似的方法，编写了一个commandParser将查询条件转换成BooleanQuery处理多字段查询的请求。尽管在查询首页中，用户输入的数据是以表单形式传入的，但我们在编写查询程序时仍旧先将其转换成了一条“contents site:... brand:...”的字符串形式。我们之所以不直接提取表单内容，是我们出于下文实现filter功能的考量，在filter功能中，用户在勾选过滤选项后会再次发出一个包含搜索的请求，网页需要保存记录此前搜索的字段传入filter请求的参数中，为了便于代码的复用，转换成字符串的方式会使程序更加可读和清晰。

另一方面，用户在结果页面可能会选择不同的检索方式，这会决定Lucene检索过程中searcher的参数，我们需要为此编写不同的搜索函数。在综合考虑整合以上两种因素后，以下是我们为检索程序提供的接口，可以看到，商品检索程序位于search\_command中，需要提供检索字符串kw和method（默认为按相关度relativity排序）两个参数。对获得的商品信息我们会做一些处理，获得filtertags等信息，具体将在前端部分进行介绍。

\begin{python}
# 统一处理搜索请求的web脚本 Web/code.py
class search:
    def GET(self):
        user_data = web.input(website="",brand="")
        kw = user_data.keyword
        if user_data.brand:
            kw += ' brand:%s' %(user_data.brand)
        if user_data.website:
            kw += ' website:%s' %(user_data.website)   # 将输入表单转换成字符串形式的请求
        method = web.input(method="relativity").method.decode('utf-8')
        vm_env.attachCurrentThread()
        contents = search_command(kw,method)     # 搜索结果
        filtertags = total(contents)           # 统计品牌、属性、特色的结果，即显示在页面左侧所必须的内容
        results = itemlis(contents)            # 要显示在页面右侧的所必需的内容
        return render.result(kw,method, results, filtertags)
\end{python}

\subsection{多字段查询处理}

在检索程序中，我们首先要对输入的query字符串进行处理，为此我们编写了一个command\_to\_query函数,统一处理各种形式的query。

\begin{python}
def command_to_query(command,analyzer):
    command_dict = parseCommand(command)          # 将字符串query转换成dict形式
    print command_dict
    seg_list = jieba.cut(command_dict['title'])
    command_dict['title'] = (" ".join(seg_list))  # 对command_dict遍历，建立BooleanQuery
    querys = BooleanQuery()
    for k,v in command_dict.iteritems():
        query = QueryParser(Version.LUCENE_CURRENT, k,
                            analyzer).parse(v)
        querys.add(query, BooleanClause.Occur.MUST)  # 各字段之间为AND关系
    return querys
\end{python}

对不同的检索方式，我们设计了如下结构以调用不同的搜索函数。
\begin{python}
def search_command(query,method):
    ... # 配置searcher、analyzer
    return globals()[method+'_search'](searcher,analyzer,query)
    # 根据method的不同调用不同函数名的搜索函数
\end{python}

至此，我们完成了搜索程序接口的设计，并且实现了商品的多字段高级搜索。

\section{商品按属性排序}

对具体的函数设计而言，我们有按相关度排序、按价格排序和按评分排序。相关度排序检测搜索结果与商品名称信息的匹配度，可以调用Lucene内置的scoreDocs方法实现，在此前的实验中已经完成，不作详述。对价格和评分排序，我们在建立索引时已经将这些信息用Lucene内置的LONG Field进行存储，我们只需为其建立对应的SortField，Lucene就可以实现按排序执行查找，以按评分查找为例，对应搜索程序的脚本如下所示。

\begin{python}
def rank_search(searcher, analyzer, command):
    rank_sorter = Sort(SortField("score",SortField.Type.LONG,True))  # True表明降序排序
    query = command_to_query(command,analyzer)
    scoreDocs = searcher.search(query, 150, rank_sorter).scoreDocs
    return read_results(scoreDocs,searcher) 
    # read_results函数提取搜索结果中的必要信息，将在前端部分介绍
\end{python}

\section{图片匹配}

\section{按图片检索}


\part{Web Front-end}

\chapter{Web框架}

\section{web.py配置}

\section{Bootstrap框架}


\chapter{网页布局}

\section{搜索主页}

\section{商品信息陈列}

\section{商品过滤功能}
